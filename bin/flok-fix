#!/usr/bin/env node

var program = require('commander');
var filter = require('mout/array/filter');
var async = require('async');
var inquirer = require('inquirer');
var child_process = require('child_process');
var pluck = require('mout/array/pluck');
var filter = require('mout/array/filter');

var flok = require('./flok').my(program, ['state', 'lock', 'middleware']);

/*
flok.addFixFor('changed', function(mig, next) {});
*/


function done(err) {
  if (err) {
    flok.log.error(err, err.message);
    process.exit(1);
  }
  flok.unlock(function (err) {
    if (err) {
      flok.log.error(err, err.message);
      process.exit(1);
    }
    process.exit(0);
  });
}

function confirm(message, callback) {
  inquirer.prompt([{
    type: 'confirm',
    name: 'confirmed',
    default: false,
    message: message
  }], function (res) {
    callback(res.confirmed);
  });
}

function update(mig, next) {
  var message = 'By updating the signature you will no longer be warned about this change.  Are ' +
                'you sure you wish to ignore changes in this migration?';

  confirm(message, function (confirmed) {
    if (!confirmed) return done();

    flok.log.info({oldSignature: mig.status.signature, currentSignature: mig.signature},
                  'updating signature in status for [%s] to match current migration signature',
                  mig.title);

    mig.status.signature = mig.signature;

    flok._saveMigrationStatus(null, mig, next);
  });

}

function revert(mig, next) {
  var migs = flok.migrations;
  var migsToRevert = filter(migs.slice(migs.indexOf(mig)), { state: 'done' });
  var many = migsToRevert.length > 1;

  if (mig.isChanged) {
    console.log('If the signature has changed then the method of reverting may have been changed ' +
                'which means it may not be compatible with the version of the migration you ' +
                'previously ran.  The safest path is normally to restore the old migration, ' +
                'then revert, then install the new version again and migrate up normally.');
  }

  if (mig.isErrored) {
    console.log('The down migration will be called to roll back the changes.  If this is not ' +
                'idempotent then it could cause further damage.');
  }

  if (many) {
    console.log('Migrations are rolled back in the order they were executed therefore you will ' +
                'need to roll back the following migration(s) before being able to roll back the' +
                'broken migration:');
    var titles = pluck(pluck(migs, 'title'));
    console.log(titles.join('\n'));
  }

  var message = 'Are you sure you wish to revert ' + (many ? 'these migrations' : 'this migration');

  confirm(message, function (confirmed) {
    if (!confirmed) return done();

    flok._executeMigrations(migsToRevert, '_down', next);
  });
}

function wipe(mig, next) {

  var message = 'This is normally done after a temporal problem has been resolved (e.g. network ' +
             'error) that caused the migration to not run at all.  If any part of the migration ' +
             'has run and it is not idempotent then wiping status may be dangerous.  Are you ' +
             'sure you wish to wipe this migrations status so it can be run again?';

  confirm(message, function (confirmed) {
    if (!confirmed) return done();
    // clear all status for this migration
    flok._clearMigrationStatus(mig, next);
  });
}

function show(mig, next) {
  // run process to view and call fixit with migration again
  child_process.execFile(__dirname + '/flok-show', [mig.id], function (err, stdout, stderr) {
    console.log(stdout + stderr);
    fixit(mig, next);
  });
}

function nothing(mig, next) {
  flok.log.info('no fix action was taken for %s', mig.title);
  next();
}

var changedActions = [
  'show migration information',
  'update signature in status',
  'revert the change',
  'nothing'
];

var erroredActions = [
  'show migration information',
  'revert the change',
  'wipe status',
  'nothing'
];

var actions = {

  update: {
    confirm: null,
    fn: update
  },

  revert: {
    confirm: null,
    fn: revert
  },

  wipe: {
    confirm: null,
    fn: wipe
  },

  show: {
    confirm: null,
    fn: show
  },

  nothing: {
    confirm: null,
    fn: nothing
  }
};


function fixit(mig, next) {

  console.log('migration [%s] is blocked because of %s', mig.title,
                mig.isChanged ? 'a change' : 'an error');

  var prompt = [{
    type: 'list',
    name: 'action',
    message: 'Select desired action',
    choices: mig.isChanged ? changedActions : erroredActions,
    filter: function (val) { return val.replace(/ .*/, ''); }
  }];

  inquirer.prompt(prompt, function (res) {
    var action = actions[res.action];

    if (!action.confirm) return action.fn(mig, next);
    inquirer.prompt([{
      type: 'confirm',
      name: 'confirmed',
      message: action.confirm,
      default: false
    }], function (res) {
      if (res.confirmed) return action.fn(mig, next);
        else next();
    });

  });
}


// Load migrations
flok.load(function (err) {
  if (err) done(err);

  flok.sortMigrationsDown(function (err) {
    if (err) done(err);

    // if migration in arg then check that 1 migration
    var migId = program.args.pop();
    var borken = migId ?
      filter(flok.migrations, {id: migId}) :
      filter(flok.migrations, 'isProblem');

    if (borken.length === 1 && migId && !borken[0].isProblem) {
      flok.log.error(borken[0], 'specified migration is not broken');
      process.exit(1);
    }

    // fix em!
    if (borken.length > 0) {

      flok.lock(function (lockErr) {
        if (lockErr) return done(lockErr);
        async.eachSeries(borken, fixit, done);
      });
      return;
    }

    // nothing to fix if we're here...

    if (migId) {
      flok.log.error('unknown migration for fix: ' + migId);
      process.exit(1);
    }

    flok.log.info('you have no blocked migrations!');
    process.exit(0);

  });
});


/*
ideas
-----
create jira
make it somebody else's problem (send email)
*/